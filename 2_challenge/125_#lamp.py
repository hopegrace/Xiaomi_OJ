# -*- coding: UTF-8 -*-
# description: 一个屋子有 n 个开关控制着 n 盏灯，但奇怪的是，每个开关对应的不是一盏灯，而是 n-1 盏灯，
#               每次按下这个开关，其对应的 n-1 盏灯就会由亮变灭，或者由灭变亮。保证不会有两个开关控制同样的 n-1 盏灯。
#               现在想把灯全部开好，但是这些灯一开始的状态非常乱，最少需要按多少次开关才能使所有灯全部亮?
#
# example: input:4 2 (单组数据输入，每组数据一行，两个数 n,l 分别代表灯的数量、最开始时亮着的灯的数量（1<l<n<10000000000）)
#          output:2  (每组数据输出一个数，即能使所有灯全部亮起的最少的按开关的次数，如果无法做到灯全部亮起，输出“Impossible”)


"""
@param string line 为单行测试数据
@return string 处理后的结果
"""
# 如果避开一盏亮灯，改变其他n-1盏灯，那么就有n-m+1盏灯亮
# 如果避开一盏暗灯，改变其他n-1盏灯，那么就有n-m-1盏灯亮
# 即由m盏灯亮，可以用一步变为n-m+1盏灯亮或者n-m-1盏灯亮

# 最后应该有n盏灯亮，那么倒数第二步就是1盏灯亮，倒数第三步应该就是n-2盏灯亮，由后往前推，亮灯的盏数依次为：n-0,1,n-2,3,n-4,5,n-6......
# 也就是全亮到一个亮，再到2个暗，再到3个亮，再到4暗，再到5亮.....
# 反过来即奇数亮可以通过奇数次操作，转为全亮。

# 分情况讨论如下：1.n偶数，m偶数，则需先经过一次操作变为奇亮，则避开暗灯操作一次，变为n-m-1亮，然后再经过n-m-1次操作就行。故为1+(n-m-1)=n-m。
#              2.n偶数，m奇数，则m次即可
#              3.n奇数，m偶数,那么n-m+1和n-m-1都是偶数，不可能变为奇数盏灯亮，故"Impossible"
#              4.n奇数，m奇数，那么n-m+1和n-m-1都是奇数，都可以，那么可以转化为1和2的情形，故取n-m和m中的较小值


def solution(line):
    n, m = [int(x) for x in line.split(" ")]
    if n % 2 == 0:
        return n - m if m % 2 == 0 else m
    else:
        return "Impossible" if m % 2 == 0 else min(n - m, m)


test1 = "4 2"
print(solution(test1))
