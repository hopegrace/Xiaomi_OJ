# -*- coding: UTF-8 -*-
# description: 一个城市有n个小镇（从1开始编号），这些小镇通过m条双向火车铁轨相连，当然某些小镇之间也有公路相连。
#              为了保证每两个小镇之间的人可以方便地互访，市长就在那些没有铁轨连接的小镇间建造了公路。
#              在两个直接通过公路或铁路相连的小镇之间移动，需要花费1小时。火车只能走铁路，汽车只能走公路。
#
#              现在有一辆火车和一辆汽车同时从小镇1出发，各自前往小镇n。
#              但是，他们中途不能同时停在同一个小镇（但是可以同时停在小镇n）。
#
#              现在请你来为火车和汽车分别设计一条线路，使火车和汽车尽可能快地到达小镇n（即要求他们中最后到达小镇n的时间最短）。
#              所有的公路或铁路可以被多次使用，求当火车、汽车中各自到达小镇时间最短时，其中的较大值是多少。
#              (火车和汽车可以同时到达小镇n，也可以先后到达。)
#
# example: input:4 2 1 3 3 4 (单组测试数据，首先有2个整数n和m (2<=n<=400,0<=m<=(n*(n-1))/2 ),分别表示小镇的数目和铁轨的数目；
#                             接下来的m对数字，每对由两个整数u和v构成，表示小镇u和小镇v之间有一条铁路。(1<=u,v<=n, u!=v）
#                             输入中保证两个小镇之间最多有一条铁路直接相连。)
#          output:2  (输出一个整数，表示答案，如果没有合法的路线规划，输出 -1.)


"""
@param string line 为单行测试数据
@return string 处理后的结果
"""


def solution(line):
    def bfs(adjacency_matrix, n):  # 由于边的权重一样，用BFS:Breadth-First Search比较适合
        queue = [[0, 0]]  # 把起始点加入队列，构建一个先进先出的队列
        book = [0] * n  # book用来标识该顶点是否访问过
        book[0] = 1
        while queue:
            cur = queue.pop(0)
            for i in range(n):
                if adjacency_matrix[cur[0]][i] == 1 and book[i] == 0:  # 若从cur代表的顶点到i顶点可达且i不在队列中，i入队
                    queue.append([i, cur[1] + 1])
                    book[i] = 1
                    if i == (n - 1):  # 如果到了目标顶点，就返回距离
                        return cur[1] + 1

    edges = [int(x) for x in line.split(" ")]
    n = edges.pop(0)
    m = edges.pop(0)
    if m == 0 or m == ((n * (n - 1)) / 2):
        return -1
    railway_matrix = [[-1] * n for i in range(n)]  # 用邻接矩阵表示图。-1代表不可达，0表示自身，1表示相连。
    highway_matrix = [[1] * n for i in range(n)]   # 注意list是可变类型，不能用[[-1] * n] * n来创建一个二维矩阵
    for i in range(0, 2 * m, 2):
        railway_matrix[edges[i] - 1][edges[i + 1] - 1] = 1  # 原来是用1到n表示各城市，这里使用0到n-1表示，故要减1
        railway_matrix[edges[i + 1] - 1][edges[i] - 1] = 1
        highway_matrix[edges[i] - 1][edges[i + 1] - 1] = -1
        highway_matrix[edges[i + 1] - 1][edges[i] - 1] = -1
    for i in range(n):
        railway_matrix[i][i] = 0
        highway_matrix[i][i] = 0

    return max(bfs(railway_matrix, n), bfs(highway_matrix, n))


test1 = "4 2 1 3 3 4"
print(solution(test1))  # 2

test2 = "6 6 1 3 1 2 2 4 4 6 3 5 3 6"
print(solution(test2))  # 2

# 由于没有铁轨直接相连的城市间修了公路，所以两个城市之间要么有铁路，要么有公路。很明显，汽车和火车不会同时停靠在同一个城市。
# 所以可以对火车求最短路，再对汽车求最短路，然后取最大值就可以了。用Dijkstra算法和BFS都可以。
# 另外要注意，m=0时要输出-1，即没有铁路，故火车到不了。如果m=(n*(n-1))/2，则说明没有公路，故汽车到不了，也是输出-1.

# 图论中最短路径问题总结 https://www.cnblogs.com/thousfeet/p/9229395.html

########################################## 1.深度或广度优先搜索算法 #################################################
#   适用于单源最短路径问题，固定两点之间的最短路，尤其是广度优先搜索算法适用于边权值相同的情况。
#   DFS:Depth-First Search  BFS: Breadth-First Search
#
# DFS算法的关键思想仅在于解决当下该如何做，至于“下一步如何做”则与“当下该如何做”是一样的，把参数改为进入下一步的值再调用一下dfs()即可。
# 而在写dfs函数的时候就只要解决当在第step的时候你该怎么办，通常就是把每一种可能都去尝试一遍。
# 当前这一步解决后便进入下一步dfs(step+1)，剩下的事情就不用管它了。
# 基本模型是：
# void dfs(int step)
# {
#     判断边界
#     尝试每一种可能 for(int i = 1; i <= n; i++)
#     {
#         继续下一步 dfs(step+1)
#     }
# }
# 可以概括为以下：初始条件下所有节点为白色，选择一个作为起始顶点，按照如下步骤遍历：
#               a. 选择起始顶点涂成灰色，表示还未访问
#               b. 从该顶点的邻接顶点中选择一个，继续这个过程（即再寻找邻接结点的邻接结点），一直深入下去，
#                   直到一个顶点没有邻接结点了，涂黑它，表示访问过了
#               c. 回溯到这个涂黑顶点的上一层顶点，再找这个上一层顶点的其余邻接结点，继续如上操作，
#                   如果所有邻接结点往下都访问过了，就把自己涂黑，再回溯到更上一层。
#               d. 上一层继续做如上操作，直到所有顶点都访问过。
#
# DFS是访问某个定点后，需要递归地访问此顶点的所有未访问的相邻顶点。
# 而BFS算法则是在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。
#               a .首先选择一个顶点作为起始结点，并将其染成灰色，其余结点为白色。
#               b. 将起始结点放入队列中。
#               c. 从队列首部选出一个顶点，并找出所有与之邻接的结点，将找到的邻接结点放入队列尾部，
#                   将已访问过结点涂成黑色，没访问过的结点是白色。如果顶点的颜色是灰色，表示已经发现并且放入了队列，
#                   如果顶点的颜色是白色，表示还没有发现。
#               d. 按照同样的方法处理队列中的下一个结点。
# 基本就是出队的顶点变成黑色，在队列里的是灰色，还没入队的是白色。


################################################## 2.Floyd算法 ###################################################
#   适用于求解任意两点之间的最短路。显然，可以进行n**2次DFS或者BFS。但是可以发现，如果要让两点之间的路程变短，只能通过第三个点的中转。
#   事实上，每个顶点都有可能使另外两个顶点之间的距离变短，这种通过中转变短的操作叫做松弛。
#   先允许1号顶点作为中转给所有两两松弛一波，再允许2号、3号...n号都做一遍，就能得到最终任意两点间的最短路了。
#   核心代码如下：for(int k = 1; k <= n; k++)
#                   for(int i = 1; i <= n; i++)
#                        for(int j = 1; j <= n; j++)
#                               if(e[i][j] > e[i][k]+e[k][j])
#                                   e[i][j] = e[i][k]+e[k][j];


############################################## 3.Dijkstra算法 ######################################################
#  适用于单源最短路径问题，基本思想：每次找到离源点（如1号结点）最近的一个顶点，然后以该顶点为中心进行扩展，
#  最终得到源点到其余所有点的最短路径。基本步骤是：
#       a. 所有结点分为两部分：已确定最短路的结点集合P、未知最短路的结点集合Q。
#           最开始，P中只有源点这一个结点。（可用一个book数组来维护是否在P中）
#       b. 在Q中选取一个离源点最近的结点u（dis[u]最小）加入集合P。然后考察u的所有出边，做松弛操作。
#       c. 重复第二步，直到集合Q为空。最终dis数组的值就是源点到所有顶点的最短路。
#  Dijkstra是一种基于贪心策略的算法。每次新扩展一个路径最短的点，更新与它相邻的所有点。
#  当所有边权为正时，由于不会存在一个路程更短的没扩展过的点，所以这个点的路程就确定下来了，这保证了算法的正确性。
#  但也正因为这样，这个算法不能处理负权边，因为扩展到负权边的时候会产生更短的路径，有可能破坏了已经更新的点路程不会改变的性质。
#  而下面的Bellman-Ford算法可以解决该问题，同样是解决单源最短路径，但它能解决前几种方法中不能解决的负权边问题。


############################################## 4.Bellman-Ford算法 ######################################################
#  适用于单源最短路径问题，可以解决负权边。主要思想：
#  对所有的边进行n-1轮松弛操作，因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。
#  换句话说，第1轮在对所有的边进行松弛后，得到的是从1号顶点只能经过一条边到达其余各定点的最短路径长度。
#  第2轮在对所有的边进行松弛后，得到的是从1号顶点只能经过两条边到达其余各定点的最短路径长度。这样一直下去，进行n-1轮松弛。
#  核心代码：
#       for(int i = 1; i <= n; i++) dis[i] = INF;
#       dis[1] = 0; //初始化dis数组，只有1号的距离为0
#       for(int k = 1; k <= n-1; k++) //进行n-1轮松弛
#           for(int i = 1; i <= m; i++) //枚举每一条边
#               if(dis[v[i]] > dis[u[i]] + w[i]) //尝试进行松弛
#                    dis[v[i]] = dis[u[i]] + w[i];
#
#  此外，Bellman-Ford算法还可以检测一个图是否含有负权回路。如果在进行了n-1次松弛之后，仍然存在某个dis[v[i]] > dis[u[i]] + w[i]的情况，
#  还可以继续成功松弛，那么必然存在回路了（因为正常来讲最短路径包含的边最多只会有n-1条）。


