# -*- coding: UTF-8 -*-
# description: 给出一个无序的数列，找出其中缺失的第一个正数，要求复杂度为 O(n)
#              如：[1,2,0]，第一个缺失为3。 如：[3,4,-1,1]，第一个缺失为2。
# example: input:1,2,0 // 3,4,-1,1 // -1,-3,-5 // 1,2,3 // -1,-10,0
#          output:3    // 2        // 1        // 4     // 1


"""
@param string line 为单行测试数据
@return string 处理后的结果
"""


def solution(line):
    number = [int(x) for x in line.strip().split(',')]
    for i in range(len(number)):
        while number[i] > 0 and number[i] < len(number) and number[i] != number[number[i] - 1]:
            number[number[i] - 1], number[i] = number[i], number[number[i] - 1]

    for i in range(len(number)):
        if number[i] != (i + 1):
            return i + 1
    return len(number) + 1


print(solution('1,2,0'))
print(solution('3,4,-1,1'))
print(solution('-1,-3,-5'))
print(solution('1,2,3'))
print(solution('-1,-10,0'))

# 本题的难点在于只能使用常数级别的空间，也就是说，不能开辟一个flag数组，若出现某个数，就将flag值标1，最后看flag数组第一个为0的下标。
# 本题的思路是从前往后将数放到它正确的位置上去。举个例子，假设有序列[4,2,6,1,-3]，首先看第一个数4，它正确的位置应该是在序列的第4个位置
# （位置数从1开始，正确的位置是第一个位置放1，第二个位置放2，第三个位置放3……最后我们只要看哪个位置放的不是理想的数，那么它就是第一个缺失的正数）。
# 我们将4与第4个位置上的“1”进行交换，序列变成[1,2,6,4,-3]；接着我们还是看第一个数，现在变成了“1”，它的确在它正确的位置，
# 好了，我们再看第二个数2，也在正确的位置。第三个数6，本来应该放在第6个位置，可是该序列总共就5个位置，所以不移动；
# 第四个数4在它的正确位置，不动；第五个数是负数，不动。
# 最后，从前往后看，发现在第三个位置本该出现的3没有出现，所有该序列缺失的第一个正数是3。
#
# 所以归纳来说，将每个数放在它正确的位置，前提是该数是正数，并且该数小于序列长度，并且它正确位置上的那个数不是它，
# 也就是说，把4要放在第4个位置，要保证第4个位置上的数不是4，如果是4的话，交换前后没什么变换，把两个4移来移去，还会造成死循环。
