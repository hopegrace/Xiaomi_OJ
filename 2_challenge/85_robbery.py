# -*- coding: UTF-8 -*-
# description: 你是一名专业劫匪，并且正在计划抢劫一条街道上的所有房子。每个房子有一定数量的现金。
#              唯一能够阻止你的就是安保系统被触发，当有两个相邻的房子在同一晚被劫时，安保系统才会自动触发。
#              现在给你一个正整数数组表示每家现金数，请求出这一晚你能在不触发安保系统时抢到的最大金额。
#
# example: input:1,2    (由逗号分隔的一串正整数，表示这一条街上每个房子内的现金数。)
#          output:2       (一个正整数，表示你能抢到的最大金额。)


"""
@param string line 为单行测试数据
@return string 处理后的结果
"""


def solution(line):
    money = [int(x) for x in line.split(",")]
    length = len(money)
    dp = [0] * (length + 1)

    for i in range(length):
        if i == 0:
            dp[i + 1] = money[i]
        else:
            dp[i + 1] = max(dp[i], dp[i - 1] + money[i])
    return dp[-1]


test = "1,2"
print(solution(test))

# 动态规划适用于具有重叠子问题和最优子结构的问题。
# 1.最优子结构
#   用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。
#   因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。
#   使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。
# 2.重叠子问题
#   如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。
#   在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。

